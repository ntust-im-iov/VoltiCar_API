from fastapi import APIRouter, HTTPException, status, Depends, Body, Form
from typing import List, Dict, Any, Optional
from datetime import datetime
from pydantic import BaseModel

# Assuming VehicleCreate and VehicleUpdate are for PlayerOwnedVehicle instances
# and should reflect its fields.
# from app.models.user import VehicleCreate, VehicleUpdate # These might need to be redefined or moved
from app.models.game_models import PlayerOwnedVehicle # Import the updated model
from app.database import mongodb as db_provider
from app.utils.helpers import handle_mongo_data # Assuming this handles ObjectId to str for _id if needed in response

router = APIRouter(prefix="/vehicles", tags=["車輛 (Player Owned Vehicles)"])

# Pydantic model for request body of creating a vehicle, aligning with PlayerOwnedVehicle
class PlayerVehicleCreateRequest(BaseModel):
    user_id: str # User.user_id (UUID)
    vehicle_id: str # This is the ID of the VehicleDefinition to base this new instance on.
    # instance_id for the new PlayerOwnedVehicle will be auto-generated by the server.
    vehicle_name: Optional[str] = None # Nickname for the vehicle
    # Other initial properties can be added here if they are set at creation time
    # For example, if battery_level, mileage etc. are set, otherwise they use model defaults.

# Pydantic model for request body of updating vehicle's dynamic info
class VehicleDynamicInfoUpdate(BaseModel):
    battery_level: Optional[int] = None
    battery_health: Optional[int] = None
    mileage: Optional[int] = None
    lastcharge_mileage: Optional[int] = None
    vehicle_name: Optional[str] = None # For updating nickname


@router.get("/user/{user_id}", response_model=List[PlayerOwnedVehicle], summary="獲取指定用戶的所有車輛")
async def get_user_vehicles(user_id: str):
    """
    根據用戶 ID，獲取該用戶擁有的所有車輛實例的詳細列表。
    - **user_id**: 用戶的唯一標識符 (UUID)。
    """
    if db_provider.player_owned_vehicles_collection is None or db_provider.users_collection is None:
        raise HTTPException(status_code=503, detail="車輛或用戶資料庫服務未初始化")
        
    user_exists = await db_provider.users_collection.find_one({"user_id": user_id})
    if not user_exists:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"用戶 '{user_id}' 不存在")

    # Changed "player_id" to "user_id" in query to match PlayerOwnedVehicle model
    vehicles_cursor = db_provider.player_owned_vehicles_collection.find({"user_id": user_id})
    vehicles_list = await vehicles_cursor.to_list(length=None)
    
    return [PlayerOwnedVehicle.model_validate(v, from_attributes=True) for v in vehicles_list]


@router.get("/{user_id}/{instance_id}", response_model=PlayerOwnedVehicle, summary="獲取單一車輛的詳細資訊")
async def get_vehicle_info(user_id: str, instance_id: str):
    """
    獲取指定用戶擁有的某個特定車輛實例的詳細資訊。
    - **user_id**: 車輛所屬用戶的唯一標識符 (UUID)。
    - **instance_id**: 車輛實例的唯一標識符 (UUID)。
    """
    if db_provider.player_owned_vehicles_collection is None:
        raise HTTPException(status_code=503, detail="車輛資料庫服務未初始化")
        
    # Changed query fields to "user_id" and "instance_id"
    vehicle_doc = await db_provider.player_owned_vehicles_collection.find_one({
        "user_id": user_id, 
        "instance_id": instance_id 
    })
    
    if not vehicle_doc:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定車輛")

    return PlayerOwnedVehicle.model_validate(vehicle_doc, from_attributes=True)

@router.post("/", response_model=PlayerOwnedVehicle, status_code=status.HTTP_201_CREATED, summary="為用戶註冊一輛新車")
async def register_vehicle(
    payload: PlayerVehicleCreateRequest = Body(...)
):
    """
    為指定用戶創建一個新的車輛實例。
    這通常在玩家購買或獲得一輛新車時調用。
    - **user_id**: 要將車輛註冊給哪個用戶。
    - **vehicle_id**: 所註冊車輛的基礎定義 ID (來自 `VehicleDefinitions` 集合)。
    - **vehicle_name**: (可選) 給這輛車取的暱稱。
    - 車輛的 `instance_id` 將由伺服器自動生成並返回。
    """
    if db_provider.player_owned_vehicles_collection is None or \
       db_provider.users_collection is None or \
       db_provider.vehicle_definitions_collection is None:
        raise HTTPException(status_code=503, detail="相關資料庫服務未初始化")

    # Check if user exists
    user = await db_provider.users_collection.find_one({"user_id": payload.user_id})
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"用戶 {payload.user_id} 不存在")

    # Check if user exists (this check is duplicated, removing one instance)
    # user = await db_provider.users_collection.find_one({"user_id": payload.user_id})
    # if not user:
    #     raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"用戶 {payload.user_id} 不存在")

    # Check if vehicle definition exists using payload.vehicle_id (which now refers to the definition's ID)
    vehicle_def_doc = await db_provider.vehicle_definitions_collection.find_one({"vehicle_id": payload.vehicle_id})
    if not vehicle_def_doc:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f"車輛定義 {payload.vehicle_id} 不存在")

    # instance_id for the new PlayerOwnedVehicle will be auto-generated by its model's default_factory.
    
    new_vehicle_instance = PlayerOwnedVehicle(
        user_id=payload.user_id, # Changed from player_id to user_id
        vehicle_id=payload.vehicle_id, # This is the foreign key to VehicleDefinition.vehicle_id
        # instance_id is NOT provided here; it will be auto-generated by the model's default_factory.
        vehicle_name=payload.vehicle_name, # This is the nickname
        # Other fields will use defaults from PlayerOwnedVehicle model
        # created_at and last_updated are now part of the model with defaults
    )
    
    vehicle_data_for_db = new_vehicle_instance.dict(by_alias=True, exclude_none=True)
    if vehicle_data_for_db.get('_id') is None and "id" in vehicle_data_for_db : # Ensure _id is not set if id is None
        del vehicle_data_for_db['_id'] 
    elif "id" in vehicle_data_for_db and vehicle_data_for_db["id"] is None: 
        del vehicle_data_for_db["id"]
    
    insert_result = await db_provider.player_owned_vehicles_collection.insert_one(vehicle_data_for_db)
    
    created_doc = await db_provider.player_owned_vehicles_collection.find_one({"_id": insert_result.inserted_id})
    if not created_doc:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="車輛註冊失敗，無法讀取已創建記錄")
        
    return PlayerOwnedVehicle.model_validate(created_doc, from_attributes=True)


# Combined update endpoint for vehicle (name, dynamic info)
@router.put("/{instance_id}", response_model=PlayerOwnedVehicle, summary="更新車輛的動態資訊或暱稱")
async def update_player_vehicle_info(
    instance_id: str,
    update_payload: VehicleDynamicInfoUpdate = Body(...)
):
    """
    更新指定車輛實例的動態資訊，例如電池電量、健康度、里程數，或修改車輛的暱稱。
    - **instance_id**: 要更新的車輛實例的唯一 ID。
    - 在請求主體中，只需提供需要更新的欄位。
    """
    if db_provider.player_owned_vehicles_collection is None:
        raise HTTPException(status_code=503, detail="車輛資料庫服務未初始化")

    update_data = update_payload.dict(exclude_unset=True) # Get only provided fields
    
    if not update_data:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="沒有提供有效的更新數據")
    
    update_data["last_updated"] = datetime.now()

    # Changed query field to "instance_id"
    result = await db_provider.player_owned_vehicles_collection.update_one(
        {"instance_id": instance_id}, 
        {"$set": update_data}
    )

    if result.matched_count == 0: # Check matched_count first
         raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="找不到指定車輛")
    if result.modified_count == 0 and result.matched_count > 0:
        # Found but nothing changed, could be a success or indicate data was same
        pass # Or return a specific message

    # Changed query field to "instance_id"
    updated_doc = await db_provider.player_owned_vehicles_collection.find_one({"instance_id": instance_id})
    if not updated_doc: # Should not happen if matched_count > 0
        raise HTTPException(status_code=500, detail="更新車輛資訊後無法讀取記錄")

    return PlayerOwnedVehicle.model_validate(updated_doc, from_attributes=True)

# Note: The original file had duplicate get_user_vehicles, it's removed.
# The old update_battery_info and update_vehicle are combined into update_player_vehicle_info.
# If separate battery update endpoint is still desired, it can be re-added.
